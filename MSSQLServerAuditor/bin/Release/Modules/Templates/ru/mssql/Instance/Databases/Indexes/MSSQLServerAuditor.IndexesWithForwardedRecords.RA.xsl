<?xml version="1.0" encoding="UTF-8"?>
<root>
	<mssqlauditorpreprocessors name="Индексы с перенаправленными записями" id="IndexesWithForwardedRecords.Description.HTML.ru" columns="100" rows="100" splitter="yes">
		<mssqlauditorpreprocessor preprocessor="HtmlPreprocessorDialog" name="Индексы с перенаправленными записями" id="IndexesWithForwardedRecords.Description.HTML.ru" column="1" row="1" colspan="1" rowspan="1">
			<xsl:stylesheet version="1.0"
					xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
					xmlns:ms="urn:schemas-microsoft-com:xslt"
					xmlns:dt="urn:schemas-microsoft-com:datatypes">

			<xsl:template match="/">

			<html>
			<head>
			</head>
			<body>

				<h1 class="firstHeading">Поиск перенаправленных записей в SQL Server 2008</h1>

				<p>Таблицы HEAP и перенаправленные записи являются основной и не выявленной проблемой
				быстродействия программы.</p>

				<p>Представьте себе клиента, использующего приложение ISV для хранения определенной
				информации о продукте в колонке varchar(200) в таблице базы данных SQL Server. В начале
				использования системы никто не вводил описания продукта длиннее 10 символов. Однако, со
				временем в папку добавлялись новые продукты, которые требовали введения префикса в
				описание. На уровне SQL это представляло собой запуск обновления, которое добавляло
				соответствующий префикс. Либо, компания сливалась с другой компанией, запись с описанием
				продукта снова менялась и состояла уже примерно из 35 символов. В этом случае для
				принятия изменений тоже использовался оператор обновления. Разумеется, если колонка была
				задана в типе varchar(200), проблем с хранением измененных значений не возникало.</p>

				<p>К сожалению, у одного клиента возникло значительное и необъяснимое замедление работы
				системы. Чем оно было вызвано?</p>

				<ul>

					<li>Обновления не изменили индексы таблицы.</li>

					<li>Таблица продукта активно использовалась, но исследование запросов пользователя
					показало, что планы выполнения запросов были верны и не изменились со временем.</li>

					<li>Проблем с оборудованием тоже не было и количество одновременных пользователей не
					возросло. </li>

					<li>Разница в размере таблицы из-за новых записей не должна была оказать сильное
					влияние, так как для записи всегда выделялось ограниченное количество рядов,
					использующих индекс.</li>

				</ul>

				<p>Итак, что же осталось в качестве причины? Пристальный обзор нескольких счетчиков
				производительности показал необычно высокое количество логических считываний в таблице
				продукта.</p>

				<p><strong>Причина:</strong> Из-за новых описаний продукта размер ряда увеличился.
				Обновления рядов вызвали <strong>прямые указатели</strong>, так как ряды не помещались в
				свои прежние слоты. Этот феномен не изменяет указатели рядов данных, а добавляет прямые
				указатели в таблицу данных. Если новый ряд становится слишком большим, SQL Server
				переносит его на новую страницу и оставляет указатель на его первоначальную ячейку.
				Таким образом, поиск ряда впоследствии будет дороже. Поиск ряда с данными в таблице
				больше не происходит путем прямого доступа посредством адреса страницы и слота. Вместо
				того, чтобы получить ряд с данными, сервер сначала должен пройти за прямым
				указателем.</p>

				<p>В SQL Server 2000 я использовал команду dbcc showcontig для подтверждения этой
				теории. Но Вам придется использовать опцию "with tableresults" для получения информации
				о "ForwardedRecords" (перенаправленных записях). Вы не сможете распознать эту проблему
				при выводе dbcc showcontig по умолчанию.</p>

				<p>С другой стороны, SQL Server 2005 предлагает команду DMV
				(sys.dm_db_index_physical_stats()), которая показывает информацию о "ForwardedRecords"
				(перенаправленных записях) (колонка "forwarded_record_count" в результатах). В обоих
				случаях количество рядов при выводе может ввести в заблуждение, так как является суммой
				«настоящего» количества рядов и числа перенаправленных записей. Запрос select count(*) в
				таблице возвращает «реальное» количество, которое Вы и ожидаете получить.</p>

				<p><strong>Как это исправить:</strong> Как только в таблице данных появляются прямые
				указатели, единственный способ избавиться от них – заново организовать таблицу. Есть
				несколько способов это сделать. Самый простой – создать кластерный индекс таблицы с
				данными и выгрузить ее из памяти. Но есть еще один способ полностью избежать прямых
				указателей – изначально создать кластерный индекс. В кластерном индексе ряды данных
				хранятся концевой вершине. Таким образом, данные всегда сортируются в соответствии с
				ключами индекса и нет необходимости в прямых указателях. Это похоже на постоянную
				реорганизацию через сеть. Приведенный ниже скрипт SQL показывает разницу между
				использованием таблицы данных и кластерного индекса, а также различие между char() and
				varchar().</p>

				<p><strong>Уровень сложности:</strong> Легкий</p>

				<p><strong>Уровень опасности:</strong> Средний</p>

				<p><a href="http://wiki.lessthandot.com/index.php/Finding_Forwarded_Records_SQL_Server_2008" target="_blank">Finding Forwarded Records SQL Server 2008</a></p>

				<p><a href="http://blogs.msdn.com/b/mssqlisv/archive/2006/12/01/knowing-about-forwarded-records-can-help-diagnose-hard-to-find-performance-issues.aspx8" target="_blank">Knowing about forwarded records</a></p>

			</body>
			</html>
			</xsl:template>
			</xsl:stylesheet>
		</mssqlauditorpreprocessor>
	</mssqlauditorpreprocessors>
</root>

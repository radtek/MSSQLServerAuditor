\documentclass[10pt,a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[left=2cm,right=1.5cm,top=1.5cm,bottom=1.5cm,bindingoffset=0cm]{geometry}
\usepackage[english,russian]{babel}
\usepackage[usenames,dvipsnames]{color}
\usepackage{caption}
\usepackage{listings}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{titlesec}

\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

% this style should be active for all lstlistings environments
\lstdefinestyle{all}{
	basicstyle       = \small\sffamily,
	captionpos       = t,
	columns          = fullflexible,
	extendedchars    = false,
	frame            = lrtb,
	framerule        = 1pt,
	framexleftmargin = 1pt,
	inputencoding    = utf8x,
	keepspaces       = true,
	showstringspaces = false,
	tabsize          = 2
}

% this style should be active (additionally to "all") for "input" lstlistings environments
\lstdefinestyle{input}{
	commentstyle     = \itshape\color{red},
	tabsize          = 2
}

\lstset{
	basicstyle       = \tffamily,
	captionpos       = t,
	columns          = fullflexible,
	commentstyle     = \color{gray}\upshape,
	extendedchars    = false,
	frame            = 0rtb,
	framerule        = 0pt,
	framexleftmargin = 0pt,
	inputencoding    = utf8x,
	keepspaces       = true,
	language         = C,
	showstringspaces = false,
	stringstyle      = \bf,
	tabsize          = 2
}

\lstset{
	basicstyle       = \small\sffamily,
	captionpos       = t,
	columns          = fullflexible,
	commentstyle     = \color{gray}\upshape,
	extendedchars    = false,
	frame            = 0rtb,
	framerule        = 0pt,
	framexleftmargin = 0pt,
	inputencoding    = utf8x,
	keepspaces       = true,
	language         = XML,
	showstringspaces = false,
	stringstyle      = \bf,
	tabsize          = 2
}

%\lstset{ %
%	language=XML,                  % выбор языка для подсветки (здесь это XML)
%	%basicstyle=\small\sffamily,    % размер и начертание шрифта для подсветки кода
%	%numbers=left,                  % где поставить нумерацию строк (слева\справа)
%	%numberstyle=\tiny,             % размер шрифта для номеров строк
%	%stepnumber=1,                  % размер шага между двумя номерами строк
%	%numbersep=5pt,                 % как далеко отстоят номера строк от подсвечиваемого кода
%	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
%	showspaces=false,              % показывать или нет пробелы специальными отступами
%	showstringspaces=false,        % показывать или нет пробелы в строках
%	showtabs=false,                % показывать или нет табуляцию в строках
%	%frame=single,                  % рисовать рамку вокруг кода
%	tabsize=2,                     % размер табуляции по умолчанию равен 2 пробелам
%	%captionpos=t,                  % позиция заголовка вверху [t] или внизу [b]
%	breaklines=true,               % автоматически переносить строки (да\нет)
%	breakatwhitespace=false,       % переносить строки только если есть пробел
%	%escapeinside={\%*}{*)},        % если нужно добавить комментарии в коде
%	morekeywords={encoding,xs:schema,xs:element,xs:complexType,xs:sequence,xs:attribute}
%}

\lstdefinelanguage{XML}{
	%basicstyle      = \ttfamily\color{darkblue}\bfseries,
	basicstyle      = \ttfamily,
	morestring      = [b]",
	morestring      = [s]{>}{<},
	morecomment     = [s]{<?}{?>},
	stringstyle     = \color{black},
	identifierstyle = \color{darkblue},
	keywordstyle    = \color{cyan},
	morekeywords    = {xmlns,version,type}% list your attributes here
}

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}
\renewcommand{\lstlistingname}{Пример}

\title{ТЕХНИЧЕСКОЕ ЗАДАНИЕ НА ДОРАБОТКУ УТИЛИТЫ ГЕНЕРАЦИИ ОТЧЁТА БАЗЫ ДАННЫХ. ВЕРСИЯ 0.3.1}
\date{3 мая 2013 г.}
\author{Алексей Сайченко}

\setcounter{tocdepth}{4}

\begin{document}
\maketitle
\tableofcontents

Утверждено

\section{Общие сведения}

\subsection{Полное наименование системы}

Система построения отчётов о системе управления базами данных MS SQL Server® MSSQLServerAuditor.

\subsection{Краткое наименование системы}

MSSQLServerAuditor, программа, утилита, система.

\section{Требования}

\subsection{Требования к информационной и программной совместимости}

Модель системы должна работать под управлением ОС Windows 7, поэтому требуется
совместимость исполняемого модуля и библиотек динамического подключения
стандартам, используемым этими ОС на платформе IBM PC. Для доступа к базам
данных требуется наличие установленного ядра работы с БД Microsoft SQL Server
(клиенская часть) и библиотеки .Net 4.x.

\subsection{Требования к процессу разработки программы}

Исполнитель руководствуется соглашением по оформлению кода команды RSDN
(http://www.rsdn.ru/article/mag/200401/codestyle.XML). В случае
неопределённостей или неясностей Заказчик и Исполнитель вырабатывают дополнение
к стандарту RSDN (не противоречешие ему) до начала разработки. При приёме
каждого этапа Заказчик вправе настаивать на оформлении кода программной
разработки в соответствии со стилем RSDN до закрытия соответствующего этапа.

\subsection{Требования к программной документации}

Исполнитель подготавливает комментарии в программе в формате необходимом для
автоматической генерации документации средствами выбранной системы разработки.
Исполнитель подготавливает инструкции по генерации документации и необходимые
программные утилиты. Документация должна быть полностью автоматически
сгенерирована и обновляется в конце каждого этапа. Наличие обновлённой
документации обязательное требование приёмки этапа.

\section{Права собственности}

Заказчик обладает полным правом собственности на весь разработанный программный
код, документацию и прочие документы. Исполнитель обязан удалить весь
разработанный программный код и сопровождающие документы после окончания
проекта. Упоминание участия Исполнителя в разработке возможно только при
получении согласия Заказчика в письменном виде.

\section{Порядок разрешения споров}

Стороны договариваются о разрешении любых споров во внесудебном порядке путём
проведения переговоров. При несогласии между Заказчиком и Исполнителем после
переговоров дальнейшая разработка и сотрудничество программы прекращается и
оплата за последний этап не производится. Заказчик настаивает на безусловном
соблюдении всех пунктов данного технического задания и дополнителных документов
к техническому заданию Исполнителем.

\section{Разработка}

\subsection{Основания для разработки}

Проект Заказчика. Договор между Исполнителем и Заказчиком на основании
проведения конкурса FreeLance.ru

\subsection{Назначение разработки}

Коммерческий проект Заказчика.

\subsection{Источники и порядок финансирования}

Собственные средства Заказчика.

\subsection{Порядок оформления и предъявления заказчику результатов работ}

Заказчик оценивает работу и информирует Исполнителя путём заведения тикетов об
ошибках и несоответствиях. Исполнитель выкладывает все программные коды,
документацию, технические руководства, другие сопровождающие документы на
выбранный сервер управления хранением исходных кодов программ.

\subsection{Порядок контроля и приемки}

Оплата каждого из завершённых этапов производится после тестирования Заказчиком
и подписания актов приёмки на основе итоговой таблицы приёма работы (акт
составляет Исполнитель). Каждый этап оплаты фиксируется в дополнительном
документе, приложению к техническому заданию.

\subsection{Итоговая таблица приёма работы}

\begin{table}
\begin{center}
\noindent\begin{tabularx}{\linewidth}{|c|X|c|}

		\hline

		\textbf{N} & \textbf{Тип проверки} & \textbf{Стоимость} \\

		\hline

		\multirow{6}{*}{1} & Настройки графика: & \multirow{6}{*}{10\%} \\

		   & 1. Процентные размеры & \\

		   & 2. Формат отображения чисел & \\

		   & 3. Корректная обработка XML & \\

		   & 4. Доработка округления & \\

		   & 5. Цвета и штриховки & \\

		\hline

		\multirow{3}{*}{2} & Интерактивность графика: & \multirow{3}{*}{15\%} \\

		   & 1. Подсветка выделения & \\

		   & 2. Скрытие элементов & \\

		\hline

		\multirow{4}{*}{3} & Новые виды диаграмм: & \multirow{4}{*}{20\%} \\

		   & 1. Линейная & \\

		   & 2. Столбчатая & \\

		   & 3. Круговая & \\

		\hline

		\multirow{3}{*}{4} & Асинхронный интерфейс: & \multirow{3}{*}{15\%} \\

		   & 1. Не блокировать при запросах & \\

		   & 2. Отмена операций & \\

		\hline

		\multirow{4}{*}{5} & Интерфейс, прочее: & \multirow{4}{*}{15\%} \\

		   & 1. Выводить информацию об ошибке в диалоге & \\

		   & 2. Статусная строка & \\

		   & 3. Отображение компонентов графиков в отдельных вкладках & \\

		\hline

		\multirow{5}{*}{6} & Доработка запросного механизма: & \multirow{5}{*}{5\%} \\

		   & 1. сохранение параметров: & \\

		   & а. \textbf{rowcount} & \\

		   & б. \textbf{error} & \\

		   & в. \textbf{error\_message} & \\

		\hline

		7  & Подключения на основании лицензий & 15\% \\

		\hline

		8  & Документирование & 5\% \\

		\hline

		\multirow{3}{*}{9} & Дерево на основании шаблона, а не результатов
		запроса. Достаточно большой пласт работ, в рамках которого, скорее
		всего, придется выполнить задачу третьего приоритета по причесыванию
		кода. & \multirow{3}{*}{45\%} \\

		    & Выбор подключения(й) из списка. & \\

		    & & \\

		\hline

		\multirow{2}{*}{10} & Учет версии MS SQL в запросах & \multirow{2}{*}{25\%} \\

		   & 1. Включение параметров в запросы. & \\

		\hline

		\multirow{4}{*}{11} & Запросы & \multirow{4}{*}{10\%} \\

		   & a. Запись даты и времени результатов сервера. & \\

		   & b. Игнорировать group в файле запросов. & \\

		   & c. Не блокировать конфигурационные файлы и перечитывать их заново. & \\

		\hline

		\multirow{3}{*}{12} & Конфигурация: & \multirow{3}{*}{10\%} \\

		   & a. Проверка наличия файла пользовательской конфигурации.
		   Восстановление из системной, если его нет. & \\

		   & b. Отключаемые строки с адресом и статусом. Запись в конфигурацию.
		   & \\

		\hline

		\multirow{4}{*}{13} & Интерфейс: & \multirow{4}{*}{10\%} \\

		   & a. Контекстное меню элементов дерева. Обновление текущего узла,
		обновление текущего и дочерних узлов. Удаление кнопки «Обновить». & \\

		   & b. Перенести пункт «Конфигурация» в меню второго уровня. & \\

		   & c. Починить и улучшить локализацию. & \\

		\hline
\end{tabularx}
\end{center}
\end{table}

\section{Назначение и цели создания системы}

\subsection{Назначение системы}

Обновление программы (новая версия 0.3.1) генерации отчёта об инстансе базы
данных и параметрах работы сервера базы данных, определяемых конфигурационным
файлом.

\section{Изменения}

\subsection{Первого приоритета}

Учитывать версию MS SQL сервера в запросе для построения списка баз данных для
запросов вида scope="database". Сейчас список баз данных удваивается (в случае
если есть запросы для нескольких версий, так как версия MS SQL сервера не
учитывается).

\begin{lstlisting}[language=XML,label=MSSQLServerAuditor.Query.xml,caption=MSSQLServerAuditor.Query.xml]
<sql-select name="DatabaseObjectsCount" group="Instance\Audit\Databases\Objects" scope="database">
	<database-select-text MinSupportedVersion="9.*" MaxSupportedVersion="*" signature="">
</sql-select>
\end{lstlisting}

Рис. Двоение списка баз данных

Вместо диалога подключения к произвольному серверу брать список серверов и
параметров авторизации только из файла конфигурации
MSSQLServerAuditor.Connections.xml. Учесть что пользователь может подключаться
как к одному отдельному экземпляру базы данных, так и к нескольким экземплярам
сервера одновременно. Каждая группа подключений определяет шаблон, на основе
которого будет строится иерархическое дерево.

\begin{lstlisting}[language=XML,label=MSSQLServerAuditor.Connections.xml,caption=MSSQLServerAuditor.Connections.xml]
<?xml version="1.0" encoding="UTF-8"?>
<MSSQLServerAuditorConnections xmlns:xi="http://www.w3.org/2003/XInclude" version="1.0">

	<connections name="PROD" template="MSSQLServerAuditor.Template.PROD.xml">
		<connection name="DBA Monitoring" instance="PRODSYD125V">
			<authentication isWindows="true" username="" password=""/>
		</connection>
		<connection name="FCM AUS" instance="PRODSYD126V">
			<authentication isWindows="true" username="" password=""/>
		</connection>
		<connection name="FCM NZ" instance="PRODAKL001P">
			<authentication isWindows="true" username="" password=""/>
		</connection>
		<connection name="Reporting Server 2000" instance="PRODSYD041P">
			<authentication isWindows="true" username="" password=""/>
		</connection>
	</connections>

	<connections name="BCP" template="MSSQLServerAuditor.Template.BCP.xml">
		<connection name="Certegy" instance="BCPSYD001P">
			<authentication isWindows="true" username="" password=""/>
		</connection>
		<connection name="VMWare" instance="BCPSYD006V">
			<authentication isWindows="true" username="" password=""/>
		</connection>
	</connections>

	<connections name="DEV" template="MSSQLServerAuditor.Template.DEV.xml">
		<connection name="Reporting 2000" instance="devsyd004v">
			<authentication isWindows="true" username="" password=""/>
		</connection>
	</connections>

</MSSQLServerAuditorConnections>
\end{lstlisting}

В файл запросов MSSQLServerAuditor.MSSQLQuery.xml ввести поддержку использования
параметров запросов и соответственно изменить файл шаблонов (о шаблонах пункт
ниже) чтобы можно было задавать значения этих параметров. Вот как может
выглядеть строка определения параметра запроса.

\begin{lstlisting}[language=XML,label=MSSQLServerAuditor.MSSQLQuery.xml,caption=MSSQLServerAuditor.MSSQLQuery.xml]
<sql-select-parameters>
	<sql-select-parameter name="@intMonthInHistory" type="INTEGER" isnull="false" default="1"/>
</sql-select-parameters>
\end{lstlisting}

Обрабатывать дополнительный конфигурационный файл шаблонов, находящийся в
директории программы. Файл задаёт конфигурационное иерархическое дерево в
главном окне программы, а также определяет какие запросы требуются исполнить,
параметры самих запросов и результирующий XML документ. В настоящее время
конфигурационное дерево определяется целиком файлом запросов
MSSQLServerAuditor.MSSQLQuery.xml, а соответствующая страница формируется на
основе шаблона в директории Templates. Недостатки такого подхода – запросы и
представление результатов смешаны, нет возможности сделать интерфейс
многоязычным, сложность изменения структуры из-за необходимости вносить
изменения в несколько мест: файл запроса, файл в директории Templates и сам файл
шаблона.

Конфигурационное дерево в текущей версии Для решения проблемы вводятся
дополнительные файлы шаблона MSSQLServerAuditor.Template.<Уникальное имя>.xml со
следующей структурой:

\begin{lstlisting}[language=XML,label=MSSQLServerAuditor.Template.xml,caption=MSSQLServerAuditor.Template.xml]
<?xml version="1.0" encoding="UTF-8"?>
<MSSQLServerAuditorTemplate xmlns:xi="http://www.w3.org/2003/XInclude" version="1.0">
	<template name = "instance">
		<i18n name="en" file="">
			Instance
		</i18n>
		<i18n name="ru" file="">
			Экземпляр
		</i18n>

		<template name="audit">
			<i18n name="en" file="">
				Audit
			</i18n>
			<i18n name="ru" file="">
				Аудит
			</i18n>

			<template name="jobs">
				<i18n name="en" file="Instance\Audit\MSSQLServerAuditor.Jobs.en.xsl">
					SQL Agent Jobs
				</i18n>
				<i18n name="ru" file="Instance\Audit\MSSQLServerAuditor.Jobs.ru.xsl">
					Регулярные задания
				</i18n>
				<sql-select file="SQLQuery.xml" name="GetJobsExecutionHistory" hierarchy="Instance\Audit\Jobs\LastMonth">
					<parameter name="@intMonthesInHistory" value="1"/>
				</sql-select>
				<sql-select file="SQLQuery.xml" name="GetJobsExecutionHistory" hierarchy="Instance\Audit\Jobs\LastTwoWeek">
					<parameter name="@intWeeksInHistory" value="2"/>
				</sql-select>
				<sql-select file="SQLQuery.xml" name="GetJobsExecutionHistory" hierarchy="Instance\Audit\Jobs\LastWeek">
					<parameter name="@intWeeksInHistory" value="1"/>
				</sql-select>
				<sql-select file="SQLQuery.xml" name="GetJobsExecutionHistory" hierarchy="Instance\Audit\Jobs\LastTwoDays">
					<parameter name="@intDaysInHistory" value="2"/>
				</sql-select>
				<sql-select file="SQLQuery.xml" name="GetJobsExecutionHistory" hierarchy="Instance\Audit\Jobs\Today">
					<parameter name="@intDaysInHistory" value="1"/>
				</sql-select>
			</template>
		</template>
	</template>
</MSSQLServerAuditorTemplate>
\end{lstlisting}

Где поле hierarchy=”” задаёт иерархическое вложенное дерево при построении XML
файла результатов. Поле file=”” задаёт относительный путь к файлу шаблона
относительно директории Templates. Поле i18n name="ru" задаёт имя в меню справа
и определяется настройками языкового интерфейса.

Проверять наличие файла \textbf{MSSQLServerAuditor.UserSettings.xml} в домашней
директории пользователя и создавать файл путём копирования его из системной
директории если он отсутствует. Не блокировать интерфейс программы во время
исполнения запросов. Должна быть возможность работы с программой, передвижения
главного окна, переключения между закладками во время выполнения запросов.

При неудачном вводе имени сервера – иметь возможность отменить (прервать
процесс соединения с сервером).

При получении ошибке о выполнении запроса или ошибки связанной с цифровой
подписью, выводить название запроса и текст ошибки в диалоговом окне

Имя инстанса сервера, имя пользователя и время последнего обновления данных
выводить в статусной строке утилиты. В случае домена, отдельно выводить название
домена и имя пользователя. За образец взять строку статуса \textbf{MS SQL
Management Studio}, но со следующими изменениями: не выводить версию сервера,
выводить имя пользователя и домен – отдельно. Название базы данных – не
выводить. Добавить время и дату последнего обновления страницы.

Для каждого выполняемого запроса сохранять значения следущих метапеременных в
результирующем XML файле в дополнение к результатам, возвращаемом запросом.

\begin{description}
	\item[@@rowcount] - число строк в результирующем запросе

	\item[@@error] - код ошибки при выполнении запроса (0 – если нет ошибки)

	\item[@@error\_message] - сообщение об ошибке (NULL – если нет ошибки)
\end{description}

\subsection{Второго приоритета}

При формировании XML файла ответов от сервера прописывать в него дату и время
его формирования и при показе брать время из файла. Сейчас в случае перезапуска
программы данные отображаются корректно, а дата формирования самих данных не
прописана (HTML файл отображается, но дата обновления не проставлена).

В файле запросов \textbf{MSSQLServerAuditor.MSSQLQuery.xml} игнорировать
параметр \textbf{group=””}, после того как иерархическое дерево в интерфейсе
создаётся на основе конфигурационного файла шаблонов, этот параметр становится
больше не нужен.

Не блокировать файл \textbf{MSSQLServerAuditor.MSSQLQuery.xml}
во время работы программы. Открывать файл на чтение по необходимости и закрывать
после выполнения операции. Учесть, что файл может изменяться во время работы
программы, не кэшировать файл, а каждый раз перечитывать его. В настоящее время
файл блокируется программой во время её работы.

Сделать строку с адресом и строку со статусом (внизу главного окна)
отключаемыми. Добавить соответствующие опции в диалоговое окно конфигурации и в
конфигурационный файл пользователя и в системный файл (для новых пользователей
по умолчанию).

Сделать контекстное меню для элементов дерева для обновления (обновление этого
элемента и обновление этого и всех вложенных элементов). Убрать кнопку
«Обновить».

Сделать диалоговое окно в меню как меню второго уровня, так же как и прочие меню
(файл и помощь).

Изменить подход к локализации и выполнить локализацию для не локализованных
компонентов программы.

\begin{description}

	\item Сам подход к локализации контролов на экране не сильно хороший, когда
	каждому элементу нужно явно присваивать текст:

		\begin{lstlisting}[language=C,label=GetLocaleText.cs,caption=GetLocaleText.cs]
			btnNewTab.Text = locale.GetLocaleText(Name, "btnNewTab");
			mnuFile.Text = locale.GetLocaleText(Name, "mnuFile");
		\end{lstlisting}

	\item Непонятно, почему класс локализации так же является классом хранения
	настроек.

	\item Касаемо замечаний по исходному коду (только по той части, с которой
	работал при объединении):

	\item Не локализовано:

		\begin{description}

			\item кнопка «Обновить узел»

			\item сообщение на закрытие вкладки

			\item в настройках «Таймаут соединения»

		\end{description}
\end{description}

\subsubsection{Параметры графика}

Возможность задавать ширину и высоту графика в процентах от размера экрана, а
второй параметр в процентах от другого. Продумать как лучше указывать параметры,
пример только для иллюстрации идеи.

\begin{lstlisting}[language=XML,label=MSSQLServerAuditor.Parameters.xml,caption=MSSQLServerAuditor.Parameters.xml]
<Size xmlns:a="http://schemas.datacontract.org/2004/07/System.Drawing">
	<a:height>60070% width</a:height>
	<a:width>900100%</a:width>
</Size>

<Size xmlns:a="http://schemas.datacontract.org/2004/07/System.Drawing">
	<a:height>6001100%</a:height>
	<a:width>90070% height</a:width>
</Size>
\end{lstlisting}

\paragraph{Ширина графика.}

Про ширину в \%. Варианта решения при использовании HTML-отчета вижу примерно 3:

\begin{description}

	\item a) Как Вы и предлагаете: смотрим на размер окна перед формированием.
	Просто, но что будет, если пользователь отресайзит окно? В целом, можно
	генерировать новый HTML при каждом изменении размера, но не уверен, что это
	будет красиво.

	\item b) Генерировать 2 картинки: маленькую, которую видно сразу, и большую,
	которая открывается по клику на маленькой. Маленькая, допустим, шириной 800
	пикс, большая - 3000 пикс.

	\item c) Генерировать несколько картинок с определенным шагом (200-500
	пикс), а Java-script в итоговом HTML будет выбирать нужную при изменении
	размеров экрана в том числе.

\end{description}

Вариант а) полностью подходит. При изменении размеров окна генерировать новый
HTML не нужно, есть для этого специальная кнопка обновить узел. Что думаю можно
сделать, задавать размер по горизонтали в процентах, а по вертикали в долях от
размера по оси X и наоборот задавать размер в процентах по оси Y и в долях по
оси X, чтобы вид графика был «красивым». Это было бы наилучшим решением.
Собственно при обработке события нажатия на эту кнопку и будет перерисовываться
график на основе нового размера экрана.

Пользователи хотят не только смотреть на графики, но и делать анализ, типа
убирать некоторые элементы, менять масштаб. Думаю что это реально сложно сделать
в полном объёме, но вот что можно попробовать так сделать управляющий элемент
интерактивным. Например кликнуть на легенде и подстветить конкретный график, или
кликнуть на элементы легенды и отключить некоторые элементы которые неинтересны
для анализа.

\paragraph{Аналитика.}

Про аналитику. Тут стоит определиться, где эта интерактивность должна быть. Если
в HTML-отчете, то делаться все это будет весьма сложно, нужно будет отказаться
от использования MS Chart и рендерить картинку средствами Java-script. Если мы
говорим, что компонент графика на форме продолжает жить (отдельно от HTML-отчета
с таблицами), то пожелания вполне реализуемы.

Однозначно не в HTML отчёте, это будет в отдельном окне. В интерфейсе программы
сейчас есть две вкладки (HTML и XML), можно сделать ещё одну с MS Chart и вся
аналитика только там. Я не планирую никаких элементов основанных на Java-script.
Т.е. HTML картинка с отчётом остаётся жить для отчёта (и как графическая
картинка), для просмотра, а вся интерактивность отдельна в отдельной новой
вкладке назовём её Chart. Вот уже реализованный пример с XML вкладкой. Что можно
сделать это по нажатию мыши на графике окрывать вкладку с элементом MS Chart.
Это было бы наилучшим решением для меня.

\paragraph{Новые виды диаграмм.}

Новые виды диаграмм должны быть независимы друг от друга и конфигурироваться в
XSL по аналогии с уже сделанным графиком, или требуется какая-то интерактивность
для переключения между ними?

Новые виды диаграмм будут совершенно независимы от друг друга. Не планируется
никакой интерактивности для переключения. Желательно иметь один и тот же код для
генерации (просто ускорит разработку и код будет проще). И очень бы хотелось
чтобы конфигурационные свойства были одинаковыми, так будет проще составлять
отчёт и подключать графики, в идеале одни и те же параметры, только тип графика
разный .

\paragraph{Линейная диаграмма.}

Сделать обычную линейную диаграмму в дополнение к текущему графику.
Соответственно данные будут описание параметра и его значения (в качестве
значения может выступать число размерность в временном интервале, байтах, и иное
(не определённое)).

Рис.1 Пример линейной диаграммы

\paragraph{Столбчатая диаграмма.}

Сделать столбчатую диграмму в дополнение к текущему графику. Вместо графика
столбики с подписями. Соответственно данные будут описание параметра и его
значения (в качестве значения может выступать число размерность в временном
интервале, байтах, и иное (не определённое)).

Хочу внести ясность в термин "размерность в временном интервале". Это
подразумевает значение часов/минут/секунд, или пару точек начало/конец? Просто
слово "интервал" вводит в заблуждение. Да, значение в часах, минутах, секундах,
не пара точек. Конкретный момент времени.

Рис.2 Пример столбчатой диаграммы для размеров баз данных

\paragraph{Круговая диаграмма.}

Сделать круговую диграмму в дополнение к текущему графику. Вместо графика круг,
разделённый на сектора. Соответственно данные будут описание параметра и его
значения (в качестве значения может выступать число размерность в временном
интервале, байтах, и иное (не определённое)).

Рис.3 Пример круговой диаграммы для размеров баз данных

Сделать такие же конфигурационные параметра для оси Y как для оси X
(AxisYConfiguration). Возможность отображения горизонтальной оси типа MinorGrid.

Ввести возможность задания формата отображения данных по осям, например вместо
1000 печатать 1,000.

Корректно обрабатывать XML данные, заданные в таком виде (пропускать пробелы и
символы табуляции для значений):

\begin{lstlisting}[language=XML,label=MSSQLServerAuditor.GraphParameters.xml,caption=MSSQLServerAuditor.GraphParameters.xml]
<FirstWeekDay>
	Monday
</FirstWeekDay>

<AxisXLabelFilter>
	StartOfWeek
</AxisXLabelFilter>
\end{lstlisting}

Сейчас обработка завершается с ошибкой:

Обработка графических данных: при составлении графика огруглять значения (в
соответствии с параметром

\begin{lstlisting}[language=XML,label=MSSQLServerAuditor.GraphUnitParameters.Seconds.xml,caption=MSSQLServerAuditor.GraphUnitParameters.Seconds.xml]
<Unit>
	Second
</Unit>
\end{lstlisting}

только после составления данных. Пример ошибки, если задать параметр час, то
многие данные не отображаются на графике. Примет отображения одних и тех же
данных при параметре

\begin{lstlisting}[language=XML,label=MSSQLServerAuditor.GraphUnitParameters.xml,caption=MSSQLServerAuditor.GraphUnitParameters.xml]
<Unit>
	Hour
</Unit>

<Unit>
	Second
</Unit>
\end{lstlisting}

\paragraph{Округление.}

Про округление. Насколько я помню, оно так и работает - с округлением в конце. И
присланный график этому не противоречит. Просто те значения, что меньше 0.5, по
правилам математики уходят в 0. Возможно, в таком случае нужно заводить столбец
"прочее", или модифицировать метод округления.

А почему значение должно быть целым? Давайте сделаеть значение с запятой (пусть
будет настраиваемым параметром и тогда огруглять можно более точно). Ведь
значения могуть быть и не целыми вообще, например 0.001, 0.0015, 0.00025, так их
вообще не удастся тогда отобразить.

Про округление: возможно, неверно интерпретировал строку исходного ТЗ: "По оси Y
возможность отображения секунд (как отображено в примере) или минут (отображать
только целое количество), или количество часов (отображать только целое число)".
Сейчас начинаю подозревать, что только отметки на оси Y должны быть целыми, а
сами значения допустимы дробные.

Да, именно так. Спасибоза уточнение, моя ошибка, неточность формулировки.
Значения (сами данные) могут быть дробными.

Параметры GraphSource задавать в произвольном порядке.

Использовать больше цветов (возможно не простые цвета, типа полосочек) для более
ясного отличия графиков друг от друга. Сейчас при наличии большого числа данных
отличить графики друг от друга затруднительно.

Про цвета и штриховки: Цвета задаются палитрами (то есть списками пар <номер,
цвет>). Сейчас используется одна из предопределенных палитр. Можно будет
конфигурировтаь свою, другое дело, будут ли разные но похожие цвета различимы
среднестатистическим глазом. Штриховаться оказалось можно. Вопрос в том, будет
ли эту штриховку видно на узких столбцах.

Если бы можно менять палитру в конфигурационном файле и возможность штриховки,
это было бы достаточно. Согласен что могут быть сложности со штриховкой на узких
столбах, но возможность отконфигурировать это из xml файла было бы прекрасным
решением.

\subsection{Третьего приоритета}

\subsubsection{Рефакторинг}

Произвести упрощение, оптимизацию и системный рефакторинг кода по присланным замечаниям.

В целом же проблема более глубинная, связанная с отсутствием как целостной
модели данных (все данные раскиданы, как правило, в свойствах визуального
класса: отдельные поля, поле Tag...), так и однозначного механизма управления
ими. Немного примеров. Мы нажимаем кнопку "Обновить". При этом у нас
запрашивается список узлов для обновления следующим образом:

\begin{lstlisting}[language=C,label=FillNodeList.cs,caption=FillNodeList.cs]
void FillNodeList(TreeNode node, List<SQLTreeNodeItem> nodelist)
{
	SQLTreeNodeItem tni = new SQLTreeNodeItem();
	tni.Group = node.FullPath;
	tni.treeNodeType = ((SQLTreeNodeItem)node.Tag).treeNodeType;
	tni.RefreshDate = DateTime.Now;
	((SQLTreeNodeItem)node.Tag).RefreshDate = DateTime.Now;
	nodelist.Insert(0, tni);

	foreach (TreeNode n in node.Nodes)
	FillNodeList(n, nodelist);
}
\end{lstlisting}

Тут мы видим, что сам список строится исключительно на основе визуального
дерева. Поэтому тут нет явной типизации (поле Tag типа Object), действие всегда
должно выполняться только в потоке GUI, дата обновления записывается уже на этом
этапе, а не в процессе фактического обновления данных (а по-другому тут и не
получится особо, т.к. данные скрыты внутри визуального контрола и отдать их в
многопоточное "наружу" проблематично). Считать данные тоже непросто: нужно
обращаться именно к визуальному компоненту. Еще один пример: обработка
обновления узлов, где для каждого вызывается ShowContent:

\begin{lstlisting}[language=C,label=ShowContent.cs,caption=ShowContent.cs]
foreach (SQLTreeNodeItem tni in a.NodeList)
{
	ShowContent(group, tnt, true, bgwMain);
}
\end{lstlisting}

В самом ShowContent выполняется куча действий: сам запрос к базе, сохранение
файлов, их преобразование (что вообще слабо связано со словом Show)... при этом
результаты каждого вызова тела цикла записываются в одни и те же свойства
визуального компонента. В результате мы всегда будем видеть после нажатия
"Обновить узел" результаты для последнего узла из списка, полученного в первом
примере. Это не страшно, если обновляется единичный узел, но загадочно и
неправильно, если обновляется набор узлов.

\subsubsection{Очистка директорий}

Убрать старый установочный проект MSSQLServerAuditorSetup, а также все остальные
прочие файлы не относящиеся к проекту, оставленные по недоработке. Пример в
сборочной директории проекта.

\begin{verbatim}
Templates
MSSQLServerAuditor.exe
MSSQLServerAuditor.pdb
MSSQLServerAuditor.en.xsl
MSSQLServerAuditor.MSSQLQuery.xml
MSSQLServerAuditor.MSSQLQuery.GetVersion.xml
MSSQLServerAuditor.MSSQLQuery.i18n.xml
MSSQLServerAuditor.MSSQLQuery\_OLD.xml
MSSQLServerAuditor.PRODSDY126V.ru.html
MSSQLServerAuditor.PRODSYD126V.xml
MSSQLServerAuditor.ru.xsl
MSSQLServerAuditor.SystemSettings.xml
MSSQLServerAuditor.UserSettings.xml
MSSQLServerAuditor.vshost.exe
MSSQLServerAuditor.vshost.exe.manifest
out.xml
out2.xml
out3.xml
SQLAuditor.vshost.exe.manifest
Templates.zip
XInclude.dll
\end{verbatim}

Вместо произвольного подключения к серверу баз данных ввести выбор из доступных
вариантов, определяемых набором ключей. Без наличия действительного ключа
подключиться к серверу баз данных невозможно. Каждый пользователь должен иметь в
домашней директории файл с ключами (ключ на основе имя сервера баз данных, имя
пользователя, имя пользователя баз данных (в случае авторизации через
операционную систему имена пользователей совпадают), имя компьютера и дата
истечения лицензии). Каждая лицензия подписана цифровым ключом, в диалоговом
окне подключения проверять подлинность каждой лицензии и давать возможность
подключения только для валидных лицензий. Текущее время брать с сервера баз
данных для проверки времени лицензии. Каждай файл лицензий может включать в себя
одну или несколько лицензий. В домашней директории может быть несколько
лицензионных файлов. Формат файла лицензий аналогичен формату файла с запросами.

\section{Дополнения, пояснения, уточнения и замечания}

Параграф носит вспомогательный характер и содержит пояснения и замечания,
возникнувшие в результате обсуждения Технического Задания.

Для общности формирования результата всегда добавлять имя экземпляра базы
данных. XSL шаблон преобразования уже будет обрабатывать (решать включать или не
включать) имя экземпляра в итоговый отчёт html.

А если сделать так: есть группа, у группы 1 и более инстансов, при этом в группе
прописано, какой файл шаблона для нее использовать? Вроде бы и более гибкое
решение, и нет искусственного ограничения/условия, то есть все более
унифицировано получится.

Да, годится, давайте так и сделаем. Нужно предусмотреть что инстанс может
входить в одну или несколько групп. Возможно ещё придётся повозиться как
отображать диалог подключения, может список серверов отображать, я пока не очень
представляю. Но идея хорошая, оставляю реализацию на Ваше усмотрение.

a. Зачем нужно разделять подключение к отдельному инстансу и к группе? Нельзя ли
представить отдельный инстанс группой из одного элемента?

Нет, и это важно, я расскажу почему. Я много обдумывал это и с удовольствием
поясню. Вот пример, у меня в управлении около 180 серверов баз данных и просмотр
их состояния занимает время. Поэтому для групп серверов будут совершеннно
различные запросы (это и отражено в Т.З.), чем к индивидуальному инстансу. К
примеру список всех операций архивного копирования, которые окончились неудачно.
Или список всех заданий, которые выполнились с ошибкой, т.е. запросы будут
другими, запрос включает в себя имя инстанса, что не нужно для одного инстанса и
будут содержать некоторые специальные агрегированные значения для упрощения
администрирования. Идея в том, чтобы не просматривать простыню, а иметь только
нужную информацию перед глазами. Для детальной информации уже можно просмотреть
отдельный инстанс, и уже детально разобраться что к чему. Ещё пример, если один
из серверов недоступен – то отразить это в отчёте, для него запрос не пройдёт,
завершится с ошибкой. Т.е. различие в том что будут отдельные запросы к группе и
к индивидуальному инстансу.

b. Как должен представляться в дереве ряд инстансов (как-то должны
группироваться схожие запросы, или каждый инстанс – свой узел дерева)?

Будут специальные запросы для группы инстансов, соответственно запрос
выполняется для всех инстансов, добавляется имя инстанса в результирующий XML и
формируется один файл. Т.е. идея в группировке всей информации, не отдельного
инстанса, а для всех сразу. Т.к. запрос один, то только к результату добавляется
имя инстанса и результат готов. Если Вы работали c Management Studio 2008, там
появилась возможность выполнения запросов для группы серверов, и так же
добавляется имя инстанса к результату. Т.е. здесь похожая ситуация, т.е. нет,
каждый инстанс – НЕ отдельный узел! Вот например я регистрирую группу серверов и
для каждого из них выполняю один и тот же запрос, потом результат складываю в
один файл, добавив имя инстанса к результату.

Я правильно понимаю, что при переходе на новую организацию дерева при помощи
шаблонов, мы получаем возможность исполнять запросы индивидуально – по их имени?
Да, точно так. Идея в том, чтобы разделить запросы и их представления. Т.е.
запросы живут отдельно (запрос содержит имя, которое уникально), а файл шаблонов
содержит информацию какие запросы (один или несколько) нужно исполнить чтобы
получить XML файл ответов. Т.е. один и тот же запрос может быть в нескольких
группах и вызываться с различным набором параметров. И для формирования одного
XML файла можно задать несколько запросов. Сейчас запросы управляют
представлением информации (это неверно!) и я хочу это в корне изменить.
Разделить мух и котлет, так примерно.

Я правильно понимаю, что запросы, у которых scope="database", должны исполняться для каждой базы, которая извлекается запросом database-select-text, при этом имя каждой базы должно попадать в дерево?
Да, всё верно. Это сейчас уже сделано. В принципе работает (есть недочёты, но по сути работает). Вы правильно подметили что есть архитектурная проблема, но по сути функциональность есть уже. Попробуйте у себя на базе. Вот например создаётся дерево баз данных и для каждой базы отображается список её объектов. Сейчас проблема в том, что список баз данных строится без учёта версии и происходит задвоение иногда.

\end{document}

